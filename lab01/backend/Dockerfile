# syntax=docker/dockerfile:1.4

# Define a sintaxe do Dockerfile, permitindo features mais recentes (como ARG antes de FROM)

# ARG para a imagem base (vis√≠vel para o FROM em ambos os est√°gios)
ARG PYTHON_BASE=3.9-slim-bullseye

# --- Stage 1: Builder para instalar depend√™ncias ---
FROM python:${PYTHON_BASE} AS builder

# ARGs para o est√°gio de build DEVEM ser declarados AQUI, AP√ìS o FROM do est√°gio 'builder'.
ARG APP_USER_BUILD=builderuser
ARG APP_UID_BUILD=1000
ARG APP_GID_BUILD=1000

# LABEL: Adiciona metadados √† imagem. Substitui a instru√ß√£o depreciada 'MAINTAINER'.
LABEL org.opencontainers.image.authors="Seu Nome <seu.email@example.com>" \
      org.opencontainers.image.version="1.0.1" \
      org.opencontainers.image.description="Demonstrativo Backend Dockerfile com todas as instru√ß√µes (Python/Flask/PostgreSQL)" \
      org.opencontainers.image.source="https://github.com/seu-repo/docker-lab" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.url="https://docs.docker.com/reference/dockerfile/" \
      com.example.docker.purpose="training-lab"

# ENV: Define vari√°veis de ambiente. Dispon√≠veis durante o build e em tempo de execu√ß√£o para esta etapa.
ENV DEBIAN_FRONTEND=noninteractive \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1 \
    APP_BUILD_DIR=/tmp/build_artifacts

# WORKDIR: Define o diret√≥rio de trabalho para as instru√ß√µes subsequentes.
WORKDIR ${APP_BUILD_DIR}

# SHELL: Altera o shell padr√£o para comandos RUN. O padr√£o √© ["/bin/sh", "-c"].
# Aqui, usamos bash explicitamente para demonstra√ß√£o.
SHELL ["/bin/bash", "-c"]

# RUN: Executa comandos durante a constru√ß√£o da imagem. Pode ter m√∫ltiplas camadas.
RUN echo "Updating apt and installing build tools..." \
    && apt-get update -qq \
    && apt-get install -y --no-install-recommends \
        build-essential \
        libpq-dev \
        gcc \
        curl \
        git \
    && rm -rf /var/lib/apt/lists/* \
    && echo "Build tools installed."

# RUN: Cria um usu√°rio para o stage de build.
RUN groupadd --gid ${APP_GID_BUILD} ${APP_USER_BUILD} && \
    useradd --uid ${APP_UID_BUILD} --gid ${APP_GID_BUILD} -m ${APP_USER_BUILD}

# Adiciona o requirements.txt
ADD requirements.txt .

# üîß CORRE√á√ÉO: Instale as depend√™ncias Python como ROOT com flags corretas
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt \
    && echo "Python dependencies installed."

# Agora voc√™ pode mudar para o usu√°rio builderuser, se houver outras etapas que o exijam.
USER ${APP_USER_BUILD}

# --- Stage 2: Imagem final para execu√ß√£o (runtime) ---
FROM python:${PYTHON_BASE}

# ARGs para o est√°gio de runtime DEVEM ser declarados AQUI, AP√ìS o FROM do est√°gio final.
ARG APP_USER_RUNTIME=appuser
ARG APP_UID_RUNTIME=1001
ARG APP_GID_RUNTIME=1001

# Re-aplica LABELS para a imagem final (boas pr√°ticas para consist√™ncia).
LABEL org.opencontainers.image.authors="Seu Nome <seu.email@example.com>" \
      org.opencontainers.image.version="1.0.1" \
      org.opencontainers.image.description="Demonstrativo Backend Dockerfile com todas as instru√ß√µes (Python/Flask/PostgreSQL)" \
      org.opencontainers.image.source="https://github.com/seu-repo/docker-lab" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.url="https://docs.docker.com/reference/dockerfile/" \
      com.example.docker.purpose="training-lab"

# ENV: Vari√°veis de ambiente para o container em runtime.
ENV APP_HOME=/app \
    PYTHONUNBUFFERED=1 \
    FLASK_APP=main.py \
    FLASK_ENV=production \
    GUNICORN_BIND="0.0.0.0:5000" \
    PATH="/usr/local/bin:$PATH"

# WORKDIR: Define o diret√≥rio de trabalho principal da aplica√ß√£o.
WORKDIR ${APP_HOME}

# RUN: Cria um usu√°rio n√£o-root dedicado para seguran√ßa.
RUN groupadd --gid ${APP_GID_RUNTIME} ${APP_USER_RUNTIME} \
    && useradd --uid ${APP_UID_RUNTIME} --gid ${APP_GID_RUNTIME} -m ${APP_USER_RUNTIME} \
    && echo "Created user ${APP_USER_RUNTIME} with UID ${APP_UID_RUNTIME} and GID ${APP_GID_RUNTIME}."

# üîß CORRE√á√ÉO: Usar caminho expl√≠cito em vez de wildcard
COPY --from=builder /usr/local/lib/python3.9/site-packages /usr/local/lib/python3.9/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# RUN: Instala depend√™ncias de runtime.
RUN apt-get update -qq \
    && apt-get install -y --no-install-recommends \
        libpq5 \
        curl \
    && rm -rf /var/lib/apt/lists/* \
    && echo "Runtime dependencies installed."

# VOLUME: Define um ponto de montagem para volumes an√¥nimos ou nomeados.
VOLUME ["/var/log/app", "/tmp/app_data"]

# COPY: Copia o c√≥digo da aplica√ß√£o para o container.
COPY app/ .

# RUN: Define permiss√µes para o diret√≥rio da aplica√ß√£o.
RUN chown -R ${APP_USER_RUNTIME}:${APP_USER_RUNTIME} ${APP_HOME} \
    && chmod -R 755 ${APP_HOME} \
    && echo "Permissions set for ${APP_HOME}."

# USER: Altera o usu√°rio sob o qual as instru√ß√µes subsequentes (CMD, ENTRYPOINT) ser√£o executadas.
USER ${APP_USER_RUNTIME}

# EXPOSE: Documenta a porta que o container est√° escutando.
EXPOSE 5000

# STOPSIGNAL: Define o sinal de sistema que o Docker enviar√° para o container para encerr√°-lo.
STOPSIGNAL SIGQUIT

# HEALTHCHECK: Define um comando para o Docker verificar a sa√∫de do container.
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:5000/ || exit 1

# üîß CORRE√á√ÉO: ENTRYPOINT sem vari√°vel de ambiente (forma exec)
ENTRYPOINT ["gunicorn", "--bind", "0.0.0.0:5000"]

# CMD: Fornece os argumentos padr√£o para o ENTRYPOINT.
CMD ["main:app"]